<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Ханойські вежі</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --card-bg: #0b1120;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.2);
      --accent-strong: rgba(56, 189, 248, 0.4);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --border: #1f2937;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%, #000 100%);
      color: var(--text-main);
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .page {
      max-width: 960px;
      width: 100%;
      padding: 24px 16px 32px;
      margin: auto;
    }

    .card {
      background: linear-gradient(145deg, #020617, #020617 45%, #020617 60%, #020617);
      border-radius: 18px;
      padding: 20px 18px 24px;
      border: 1px solid var(--border);
      box-shadow:
        0 20px 35px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(15, 23, 42, 0.7);
    }

    h1 {
      margin: 0 0 6px;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--accent-strong);
      background: rgba(15, 23, 42, 0.8);
      color: var(--accent);
    }

    .subtitle {
      margin-bottom: 16px;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.08), transparent 55%);
      border: 1px solid rgba(15, 23, 42, 0.9);
      margin-bottom: 16px;
    }

    .toolbar-left,
    .toolbar-right {
      display: inline-flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }

    label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    select {
      background: #020617;
      color: var(--text-main);
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 5px 24px 5px 10px;
      font-size: 0.9rem;
      outline: none;
      appearance: none;
      position: relative;
      cursor: pointer;
      background-image: linear-gradient(45deg, transparent 50%, var(--text-muted) 50%),
        linear-gradient(135deg, var(--text-muted) 50%, transparent 50%);
      background-position: calc(100% - 14px) 9px, calc(100% - 9px) 9px;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
    }

    input[type="number"] {
      width: 80px;
      background: #020617;
      color: var(--text-main);
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 10px;
      font-size: 0.9rem;
      outline: none;
    }

    button {
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: radial-gradient(circle at top left, var(--accent-soft), #020617);
      color: var(--text-main);
      font-size: 0.9rem;
      padding: 6px 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition:
        background 0.15s ease-out,
        transform 0.05s ease-out,
        box-shadow 0.15s ease-out,
        border-color 0.15s ease-out;
      box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.3);
    }

    button:hover {
      background: radial-gradient(circle at top left, var(--accent-strong), #020617);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.5);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .toolbar-right span {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .toolbar-right strong {
      color: var(--accent);
      font-weight: 600;
      margin-left: 4px;
    }

    .game-board {
      position: relative;
      margin: 10px 0 14px;
      padding: 18px 14px 10px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), #020617);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.7);
      display: flex;
      gap: 14px;
    }

    .tower {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      cursor: pointer;
      transform-origin: bottom;
      transition:
        transform 0.08s ease-out,
        box-shadow 0.12s ease-out,
        background 0.12s ease-out,
        border-color 0.12s ease-out;
      border-radius: 12px;
      border: 1px solid transparent;
      padding: 4px 4px 8px;
    }

    .tower:hover {
      transform: translateY(-2px);
      border-color: rgba(56, 189, 248, 0.3);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), #020617);
      box-shadow: 0 12px 20px rgba(0, 0, 0, 0.7);
    }

    .tower-selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.7), 0 16px 30px rgba(0, 0, 0, 0.85);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.2), #020617);
    }

    .tower-label {
      text-align: center;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .tower-area {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding: 4px 0 0;
    }

    .peg {
      position: absolute;
      bottom: 24px;
      width: 6px;
      height: 70%;
      max-height: 220px;
      border-radius: 999px;
      background: linear-gradient(to bottom, #1f2937, #020617);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.8), 0 5px 18px rgba(0, 0, 0, 1);
    }

    .tower-base {
      position: absolute;
      bottom: 16px;
      height: 8px;
      width: 88%;
      border-radius: 999px;
      background: radial-gradient(circle at top, #1f2937, #020617);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.85),
        0 12px 30px rgba(0, 0, 0, 1);
    }

    .tower-disks {
      position: relative;
      width: 100%;
      max-width: 220px;
      height: 220px;
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      justify-content: flex-start;
      pointer-events: none;
      padding-bottom: 24px;
      z-index: 1;
    }

    .disk {
      height: 22px;
      margin-top: 4px;
      border-radius: 999px;
      background: linear-gradient(145deg, #0ea5e9, #38bdf8);
      box-shadow:
        0 4px 10px rgba(15, 23, 42, 0.9),
        inset 0 0 0 1px rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(8, 47, 73, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ecfeff;
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      pointer-events: none;
      position: relative;
      overflow: hidden;
    }

    .disk::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.15), transparent 55%);
      opacity: 0.9;
    }

    .disk span {
      position: relative;
      z-index: 1;
    }

    #message {
      min-height: 20px;
      font-size: 0.86rem;
      color: var(--text-muted);
      padding: 6px 4px 0;
    }

    #message.message-win {
      color: #bbf7d0;
    }

    #message.message-error {
      color: var(--danger);
    }

    .footer {
      margin-top: 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      opacity: 0.8;
    }

    .footer span {
      white-space: nowrap;
    }

    .rules {
      margin-top: 16px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px dashed var(--border);
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .rules h2 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      color: var(--text-main);
    }

    .rules ol {
      margin: 0 0 6px 18px;
      padding: 0;
    }

    .rules li {
      margin-bottom: 4px;
    }

    .rules-note {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    @media (max-width: 700px) {
      .card {
        padding: 16px 12px 20px;
      }

      h1 {
        font-size: 1.3rem;
      }

      .game-board {
        flex-direction: column;
        padding: 14px 10px 8px;
      }

      .tower-disks {
        height: 190px;
      }
    }

    @media (max-width: 480px) {
      .toolbar {
        align-items: flex-start;
      }

      .toolbar-right {
        width: 100%;
        justify-content: flex-start;
      }

      .toolbar-right span {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="card">
      <h1>
        Ханойські вежі
        <span class="badge">mini-game</span>
      </h1>
      <div class="subtitle">
        Клікніть по вежі-джерелу, потім по цільовій вежі. Не кладіть більший диск на менший.
        Для демонстрації оптимального рішення використовуйте автосолвер.
      </div>

      <div class="toolbar">
        <div class="toolbar-left">
          <label for="diskCount">Кількість дисків (1–15):</label>
          <input id="diskCount" type="number" min="1" max="15" value="4" />

          <button id="resetBtn" type="button">
            ⟲ Перезапустити гру
          </button>

          <button id="solveBtn" type="button">
            ▶ Автосолвер (оптимальне рішення)
          </button>
        </div>

        <div class="toolbar-right">
          <span>Ходи: <strong id="moves">0</strong></span>
          <span>Мінімум ходів: <strong id="optimal">0</strong></span>
        </div>
      </div>

      <div class="game-board">
        <div class="tower" data-index="0">
          <div class="tower-label">Вежа 1</div>
          <div class="tower-area">
            <div class="peg"></div>
            <div class="tower-base"></div>
            <div class="tower-disks"></div>
          </div>
        </div>

        <div class="tower" data-index="1">
          <div class="tower-label">Вежа 2</div>
          <div class="tower-area">
            <div class="peg"></div>
            <div class="tower-base"></div>
            <div class="tower-disks"></div>
          </div>
        </div>

        <div class="tower" data-index="2">
          <div class="tower-label">Вежа 3</div>
          <div class="tower-area">
            <div class="peg"></div>
            <div class="tower-base"></div>
            <div class="tower-disks"></div>
          </div>
        </div>
      </div>

      <div id="message"></div>

      <div class="footer">
        <span>Мета: перенести всі диски з вежі 1 на вежу 3.</span>
        <span>Оптимальна стратегія = 2ⁿ − 1 ходів.</span>
      </div>

      <div class="rules">
        <h2>Правила гри</h2>
        <ol>
          <li>Є три вежі та N дисків різного розміру.</li>
          <li>Спочатку всі диски знаходяться на першій вежі, від найбільшого (знизу) до найменшого (зверху).</li>
          <li>За один хід можна перенести тільки один верхній диск з будь-якої вежі на іншу.</li>
          <li>Заборонено класти більший диск на менший.</li>
          <li>Мета – перенести всі диски з вежі 1 на вежу 3, дотримуючись цих правил.</li>
        </ol>
        <p class="rules-note">
          Автосолвер демонструє оптимальне рішення з початкової конфігурації (усі диски на вежі 1).
        </p>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const towers = [[], [], []];

      let numDisks = 4;
      let moveCount = 0;
      let selectedTowerIndex = null;

      let autoSolving = false;
      let autoMoves = [];
      let autoMoveIndex = 0;
      let autoTimer = null;

      const towerElements = Array.from(document.querySelectorAll(".tower"));
      const diskCountInput = document.getElementById("diskCount");
      const resetBtn = document.getElementById("resetBtn");
      const solveBtn = document.getElementById("solveBtn");
      const movesEl = document.getElementById("moves");
      const optimalEl = document.getElementById("optimal");
      const messageEl = document.getElementById("message");

      function setMessage(text, type) {
        messageEl.textContent = text || "";
        messageEl.classList.remove("message-win", "message-error");

        if (type === "win") {
          messageEl.classList.add("message-win");
        } else if (type === "error") {
          messageEl.classList.add("message-error");
        }
      }

      function updateMoves() {
        movesEl.textContent = moveCount;
      }

      function updateOptimalMoves() {
        const optimal = Math.pow(2, numDisks) - 1;
        optimalEl.textContent = optimal;
      }

      function updateUIForSolver(isRunning) {
        autoSolving = isRunning;
        if (isRunning) {
          solveBtn.textContent = "■ Зупинити автосолвер";
          diskCountInput.disabled = true;
          resetBtn.disabled = true;
        } else {
          solveBtn.textContent = "▶ Автосолвер (оптимальне рішення)";
          diskCountInput.disabled = false;
          resetBtn.disabled = false;
        }
      }

      function render() {
        towerElements.forEach((towerEl, index) => {
          const stackEl = towerEl.querySelector(".tower-disks");
          stackEl.innerHTML = "";

          towers[index].forEach((size) => {
            const diskEl = document.createElement("div");
            diskEl.className = "disk";
            diskEl.style.width = 60 + size * 18 + "px";

            const label = document.createElement("span");
            label.textContent = size;
            diskEl.appendChild(label);

            stackEl.appendChild(diskEl);
          });

          towerEl.classList.toggle(
            "tower-selected",
            selectedTowerIndex === index
          );
        });
      }

      function initGame() {
        // очищення автосолвера при перезапуску
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        autoMoves = [];
        autoMoveIndex = 0;
        updateUIForSolver(false);

        let value = parseInt(diskCountInput.value, 10);
        if (isNaN(value)) {
          value = 3;
        }
        value = Math.max(1, Math.min(15, value));
        diskCountInput.value = value;
        numDisks = value;

        towers[0] = [];
        towers[1] = [];
        towers[2] = [];

        for (let size = numDisks; size >= 1; size--) {
          towers[0].push(size);
        }

        moveCount = 0;
        selectedTowerIndex = null;
        updateMoves();
        updateOptimalMoves();
        setMessage(
          "Перенесіть всі диски з першої вежі на третю. Спочатку клікніть по вежі-джерелу, потім по цільовій вежі."
        );
        render();
      }

      function checkWin() {
        if (towers[2].length === numDisks) {
          setMessage(
            `Гру завершено за ${moveCount} ходів! Мінімально можливий результат: ${Math.pow(
              2,
              numDisks
            ) - 1}.`,
            "win"
          );
        }
      }

      function performMove(sourceIndex, targetIndex, options = {}) {
        const { fromSolver = false, skipCheckWin = false, skipMessage = false } =
          options;

        const sourceTower = towers[sourceIndex];
        const targetTower = towers[targetIndex];

        if (!sourceTower || !targetTower) {
          return false;
        }

        if (sourceTower.length === 0) {
          if (!fromSolver) {
            setMessage("На обраній вежі немає дисків.", "error");
          }
          return false;
        }

        const movingDisk = sourceTower[sourceTower.length - 1];
        const targetTopDisk = targetTower[targetTower.length - 1];

        if (typeof targetTopDisk !== "undefined" && targetTopDisk < movingDisk) {
          if (!fromSolver) {
            setMessage(
              "Неможливий хід: більший диск не можна класти на менший.",
              "error"
            );
          }
          return false;
        }

        sourceTower.pop();
        targetTower.push(movingDisk);
        moveCount += 1;
        updateMoves();
        render();

        if (!skipMessage) {
          setMessage("");
        }
        if (!skipCheckWin) {
          checkWin();
        }

        return true;
      }

      function handleTowerClick(index) {
        if (autoSolving) {
          // під час автосолвера ручні дії ігноруємо
          return;
        }

        const tower = towers[index];

        if (selectedTowerIndex === null) {
          if (tower.length === 0) {
            setMessage(
              "На цій вежі поки немає дисків. Оберіть вежу, де є диски.",
              "error"
            );
            return;
          }
          selectedTowerIndex = index;
          setMessage(
            `Обрана вежа №${index + 1}. Тепер оберіть вежу, куди перемістити верхній диск.`
          );
          render();
          return;
        }

        if (selectedTowerIndex === index) {
          selectedTowerIndex = null;
          setMessage("Вибір вежі скасовано.");
          render();
          return;
        }

        const sourceIndex = selectedTowerIndex;
        const targetIndex = index;

        const moved = performMove(sourceIndex, targetIndex);
        selectedTowerIndex = null;

        if (!moved) {
          render();
        }
      }

      function generateSolution(n, from, to, aux, moves) {
        if (n === 1) {
          moves.push([from, to]);
          return;
        }
        generateSolution(n - 1, from, aux, to, moves);
        moves.push([from, to]);
        generateSolution(n - 1, aux, to, from, moves);
      }

      function startAutoSolve() {
        // завжди починаємо з початкової конфігурації для оптимального шляху
        initGame();

        autoMoves = [];
        autoMoveIndex = 0;
        generateSolution(numDisks, 0, 2, 1, autoMoves);

        if (autoMoves.length === 0) {
          return;
        }

        updateUIForSolver(true);
        setMessage("Автосолвер демонструє оптимальне рішення…");

        autoTimer = setInterval(() => {
          if (autoMoveIndex >= autoMoves.length) {
            clearInterval(autoTimer);
            autoTimer = null;
            updateUIForSolver(false);
            checkWin();
            setMessage(
              `Автосолвер завершив оптимальне рішення за ${moveCount} ходів із мінімально можливих ${Math.pow(
                2,
                numDisks
              ) - 1}.`,
              "win"
            );
            return;
          }

          const [from, to] = autoMoves[autoMoveIndex++];
          performMove(from, to, {
            fromSolver: true,
            skipCheckWin: true,
            skipMessage: true,
          });
        }, 600);
      }

      function stopAutoSolve(manual = false) {
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        autoMoves = [];
        autoMoveIndex = 0;
        updateUIForSolver(false);

        if (manual) {
          setMessage("Автосолвер зупинено. Ви можете продовжити гру вручну.");
        }
      }

      // Події
      towerElements.forEach((towerEl, index) => {
        towerEl.addEventListener("click", () => handleTowerClick(index));
      });

      resetBtn.addEventListener("click", () => {
        initGame();
      });

      diskCountInput.addEventListener("change", () => {
        initGame();
      });

      solveBtn.addEventListener("click", () => {
        if (autoSolving) {
          stopAutoSolve(true);
        } else {
          startAutoSolve();
        }
      });

      // Ініціалізація
      initGame();
    });
  </script>
</body>
</html>
